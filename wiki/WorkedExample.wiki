#summary Demonstrations on using the code

= Basic Explosion =

For our first example we will look at the sedov_taylor.cpp file in the examples directory. Let us examine the program section by section. In lines 38-39 we define the boundaries of the computational domain. Since the computational domain is rectangle aligned with the axes, it is completely determined by two points: the lower left and upper right. The class used (SquareBox) is defined in the file “SquareBox.hpp”, which is included in line 6. In general, the best way to find where a class or a function is declared is to look it up in the doxygen documentation. 

The next instruction (lines 43-46) create a uniform cartesian mesh aligned with the axes. The first two arguments are the number of points along each axis, and the third and fourth are the bottom left and top right corners of the mesh. We get the corners directly from the boundaries of the computational domain to make sure they coincide with the ends of the mesh.

In line 49 we set up the tessellation, which we have chosen to be the Voronoi tessellation. At this point the tessellation is empty. It will be later populated by the points from lines 38-39. 

In line 52 we set up the Riemann solver, which we have chosen to be the HLLC solver.

In line 55 we set up the hydrodynamical boundary conditions, which have chosen to be rigid walls. Notice that the constructor needs to receive our Riemann solver, which is passed by reference. 

In line 58 we set up our equation of state, which we have chosen to be an ideal gas law. The ideal gas receives in its constructor the adiabatic index which we have chosen to be 5/3.

In line 61 we set up our point motion scheme. We begin by choosing the simplest method, which is the Eulerian scheme in which the points don't move at all.

In line 64 we choose our spatial reconstruction scheme. We choose the simplest option which is the piecewise constant scheme. This means that the values of variables at the edge of each cell are assumed to be the same as the value at the center. 

In lines 67-75 we define the hydrodynamic initial conditions of the simulation. These are functions that determine the value of each of the variables at each point. According to line 67, the density is uniform throughout and equal to 1. Lines 74-75 determine that the velocity is the same everywhere and equal to zero. The pressure, however, is a bit more complex. First, we define a circle (line 68), then we define two uniform functions (lines 69 and 70). Finally, in lines 71 - 73, we set it so that inside the circle the uniform function with the higher value is used, and outside the uniform function with the lower value is used.

In line 78 we set up our external source term. We want no external sources so we choose the ZeroForce class. 

In lines 81-82 we call the constructor of our simulation class. This sets up the simulation. Note that some objects are passed by value, and others by reference. Of those passed by reference, some object can be destroyed at the end of the constructor, while others must persist to the end. 

The default value of the CFL number used is 0.3. Line 85 shows how the user can override this value using the method SetCfl. 

Lines 94-97 is where we will spend most of our time. This is the main loop where the simulation is advanced in time. The first argument is the simulation object. The second argument is the termination condition. The simulation will be advanced in time until this criterion is satisfied. In our case, the criterion is given by the class SafeTimeTermination (instantiated in 92). The first argument of SafeTimeTermination is the termination time. The simulation will be advanced in time until the time is larger than that first argument. The second argument of SafeTimeTerminatino is the maximum number of time advance cycles allowed. If the simulation does not reach the target time withing that number of cycles, an error occurs. This prevents the simulation from getting stuck (hence safe). The third argument of main_loop is the time advance method. In our case, it is hdsim::TimeAdvance. This is the simplest time advance method, which is first order in time. The fourth argument of main_loop is the diagnostic function. The diagnostic function is instantiated in line 93, and defined in lines 17 - 33. Every specified number of iterations (25 in our case) it print the time and the number of cycles to the sceen.

There is a subtlety issue one should be aware of when using SafeTimeAdvance. This method terminates the time advance cycle when the time exceed a certain target time. This means that the final vale of the time may be a bit larger than the target time (the difference is bounded by the size of the last time step). In order to make sure that the final time would be exactly what we want, we use the SetEndTime method (line 89). This makes sure that the time step will never be greater than 

Finally, the information of the final state of the simulation is written to an HDF5 file (line 

Running the program should yield the following output to the screen
{{{
Sim time is 0.0122616 Step number 25 

Sim time is 0.0242269 Step number 50 

Sim time is 0.037032 Step number 75 

Finished running the simulation
}}}

= Moving The Mesh =
In order to get our mesh to move along with the fluid, we need to change our point motion scheme. We now look at the file “sedov_taylor_moving_mesh.cpp” where we have a simple example. Notice that we changed lines 62-63, so instead of having an Eulerian scheme we now have a Lagrangian scheme (object name is raw_pointmotion) which is wrapped by the RoundCells option (object pointmotion). This ensures that our cells stay rather round and stabilizes the code. 

= Second Order Accuracy =
Our next improvement will be to make our simulations second order accurate. We will examine the example given in “sedov_taylor_2nd_order.cpp”. In order to be second order accurate we need to change two things. The first is the spatial interpolation and the second in the time advancement scheme. Line 66 is changed from PCM2D to that of LinearGaussConsistent, which implements linear interpolation. The second change is in line 98 where the simulation time advancement method is changed that of the second order one.

= Adding Diagnostics =
Suppose we wanted several outputs and not just the final one? In “sedov_taylor_outputs.cpp” we show a simple example of a custom output scheme. We chose a simple scheme where every 0.01 time we output a snapshot of the simulation. In line 98 we instantiate a class that does just that. However, since we want to use both the new and the old diagnostics (rather than just replace them) we have to define a third diagnostics function, namely MultipleDiagnostics, in line 99. We then add the existing diagnostics to it (lines 100 - 101) and pass it to main_loop_2d (line 105).

= Quiz I =
Try and write a simulation for the Sod shock tube with second order accuracy. Use a domain 0<x<1, 0<y<4 with rigid walls. For the top half (y>2) use v=0,ρ=1 and P=1. For the bottom half use v=0,ρ=0.125 and P=0.1. Make the points move Lagrangianly and give a dump every 0.1 time interval and stop the simulation when t=0.5. Tip, look at the doxygen for SpatialDistribution and find the corresponding class for this problem. Compare your code to “sod_example.cpp”.

= Adding an External Source Term =
Next we add a point mass at the center as given in the file “sedov_taylor_force.cpp”. In lines 82 - 83 we define our new source term. Since gravity is a conservative force we use the ConservativeForce wrapper. In line 83 we define the acceleration class needed for the conservative force. After creating the acceleration object we pass it on to the ConservativeForce wrapper in line 83.

= Catching Errors =
What happens if the program crashes? How can we debug it efficiently? In “sedov_taylor_error.cpp” we extended our example to handle exceptions. In order to create an error we have increased the Courant number to 3. Notice that if you run this program now it will display an error once the program crashes, telling you why the program crashed. In our case it says it crashes since the pressure came out negative.

= Collision = 
In the file “collision.cpp” we simulate the collision of two blobs of matter. Since we are more interested in the blobs than the background, why not put more resolution there? In lines 50 - 53 we create points for our background while at lines 54 - 57 we set up the points for the blobs. In lines 58 - 60 we combine the three vectors into one vector that will be the input for our simulation. Since there is no class that will give us the desired initial profile for the density we need to create it by ourselves. We created a class called “CollideDensity” with the files “collide_density.hpp” and “collide_density.cpp”. In “collide_density.hpp” we start with a header guard, in line 4 we include the relevant virtual class we want to inherit from, SpatialDistribution in our case. We then define our class, its members, its constructor and of course the virtual method that we are implementing (the operator() method). In the file “collide_density.cpp” we then implement our constructor and derived method. In line 70 in “collision.cpp” we use our new class and declare an instance of it. Notice that what we would want for our velocity distribution is exactly the same as what we want for the density distribution so we can use this class for the velocity profile as well (with different numbers of course).

= Binary Star =
In this example we will try and simulate a wind emitting star in a binary system (neglecting rotation). There are several new features we are using in this example given in “binary_star.cpp”. In lines 70-83 we detail our initial hydro conditions, using a custom class called BinaryOutflowVelocity which is defined in “binary_outflow.hpp”. In lines 85-94 we set the external hydro boundary conditions to be a constant primitive on the outside. Since we will be using the cold flows flag we also need to give the external entropy per unit mass, this is done in lines 92-94. We have set our outflow to be relatively cold (compared to its kinetic energy) this might cause numerical issues. In order to prevent that we have turned on the coldflows flag in line 117. The wind is set up in lines 119-123 where we set the donor star cells to be constant. The accretion of the matter into the other star is accomplished by setting the cells around the second star to having a constant value (lines 125-128), this removes mass from the simulation. The last thing we need to take care of is the time step. Since we are using an external source, we must make sure that the time step also obeys the criteria given by the external force. This is done in lines 164-166. However, the algorithm for calculating the time step requires the acceleration from the previous time step. In order to prevent this problem for the first time step, we manually set the time step in line 131.
This example is using an Eulerian grid. Doing accretion and outflows with moving mesh is a bit more tricky and requires the usage of AMR, which we will show in future examples.

= Quiz II =
Try running a moving mesh simulation of a Sedov-Taylor explosion with spherical coordinates, while tracking how much each cell's mass belong to the initial hot material. Our solution is given in the file “sedov_taylor_3d.cpp”.

= Using AMR =
When running the Noh problem two problems occur. The first if we want to use a moving mesh, the outer cells will grow bigger and bigger since they will be moving towards the center. The second is that more and more cells will concentrate towards the center making the cells near the center smaller and smaller with time. The first problem severely hurts our spatial resolution while the second problem causes the time step to drastically fall down. The easiest way to deal with these two problems is to use AMR. In our code AMR is split into two parts. The first is RemovalStrategy, this is the criteria that tells us to remove cells. The second is RefineStrategy, this is the criteria that tells us to split a cell into 2 smaller cells. The example given in “Noh.cpp” shows how we implement this with the basic principle that if a cell is more than twice its original size we split it and if it is smaller by more than a quarter we remove it. Since we want to have a custom inflow into our domain (that is dictated by the analytical solution), we write our own custom HydroBoundaryConditions class called NohHBC in the “noh_hbc” files. We had to implement the derived methods, most of them were copied from the RigidWall class and InFlow class. The convention that we use in our code is that for SquareBox boundaries, the outer neighbor has a index of -1 while for PeriodicBox the edges contain the index of the ghost cell which will always be higher than the number of mesh points. Since the initial velocity profile is trivial and easy to implement we did not create separate files for it but rather implemented at the top of the main file. Since the flow is very cold, we have turned on the cold flows flag (in line 77) and also increased the default speed at which the cells are corrected to 0.7 since in this problem cells tend to become “unround” rather quickly. Whenever the initial points are random (as is in this case), there can be cases where cells will initially have very large aspect ratio. In order to prevent this we called the “RoundGrid” function at line 92 in the main file. This function takes the initial points and makes the tessellation rounder. In lines 103-107 we declare the AMR classes which are implemented in the “noh_amr” files. Lines 18-23 in “noh_amr.cpp” show our refinement criteria. We chose to give the spitted points a given direction that goes along with the flow, this is not really necessary in our case and we could have left the vector empty and let the default scheme do its magic (which tries to minimize the area ratio between the two new cells). In line 27 we do not return the cells that fit our criteria but rather return a list that has been processed through the RemoveDuplicatedLately method. This makes sure that a cell isn't duplicated turn after turn. We recommend using this method since otherwise in some cases excessive splitting might occur do to creation of very elongated cells. In line 45 we decide whether to remove a cell or not based on its volume and save its volume as the “merit” of the cell which will decide if neighboring cells are to be removed which one will be removed (we do not remove both neighboring cells since our removal mechanism does not allow to remove adjacent cells). In order to remove neighboring cells we use the method “RemoveNeighbors”. It is always a good idea to check that indeed you do not remove adjacent cells by using the CheckOutput method like we do in line 54. The actual process of doing the AMR is achieved in lines 142-145 in the main file right after the time step.

= Change outside the Time Step =
Sometimes it is necessary to change things outside the time step and not inside it. This is usually the case when the changes made to a cell from an a external, non hydrodynamic source changes the quantities of the cell. As a simple way to demonstrate this, we will try to simulate a heating and mass injection mechanism into the Sedov Taylor problem in “sedov_taylor_heat”. We will assume that whenever the density falls below 0.5, mass is injected into the cell until the density is 1 and it's pressure will be set to 10. In line 40 we define a new function that will take care of the heating and mass addition. Notice that in lines 52 - 53, in addition to changing the density and pressure we also change the sound speed and energy in order to keep the Primitive variable self consistent. In line 58 we wrap this function with the appropriate class (inherited from Manipulate), instantiate it in line 147, and use it in line 152, as the fifth (optional) argument of main_loop_2d.

= Restart files =
What happens if you would like to restart a simulation from a given snapshot? In “sedov_taylor_restart” we give an example of restarting a simulation from an hdf5 output (restart can also be done from the non hdf5 output as well). In line 111 we instantiate a ResetDump object which will hold the data that is read from the snapshot. We then read the data into the object in line 112 and call the appropriate constructor for our simulation in line 115. 

= Self Gravity =
In this example we will try to simulate a self gravitating Kuz'min-Toomre disc. (TBA: add equations) In “disc_self_gravity” lines 42-82 we set up the custom classes for our initial velocity and density distribution. Since we want a round outer boundary, we split our mesh generating into several parts. In the first part we create a circular mesh which gives more points at the center than at the outer edges (line 90). We then add three circles that we will later use for our outer boundary. In line 131 when we call the constructor for the RoundCells motion we pass an additional number (6*np) that tells the simulation not to move those cells. This makes sure that the outer boundary is always circular (this can also be achieved by giving them a rigid body rotation). In line 151 we instantiate the self gravity force giving it the two parameters of opening angle and smoothing length. In lines 159-162 we set our effective outer boundary. Basically, we tell the cells of the two outer rings not to change their primitive variables.

= Parallel Run =
In this subsection we will demonstrate how to run a simulation in parallel. The code can be found at “examples/sedov_taylor_parallel.py”. In line 56 we call MPI_Init to initialize mpi. In line 62 we set up a tessellation for the processes. In this simple example we choose the positions of the processes' positions at random (see line 21). In line 65 we assign the relevant points to each processor. To understand what goes on inside, we begin from the innermost part. CartesianGridGenerator is an object that takes an index and returns a point. Each processor evaluates a different range of indices and obtains a different set of point (usually not the points that lie inside its process voronoi cell). The function distribute_grid then sorts out the points and transfers them to their respective processes. Thus, each process ends up with all the points inside its voronoi cell. In line 105 we see that the hdsim constructor is called with an extra argument, the tessellation of the processes. In the main loop section, the diagnostic ConsecutiveSnapshots is already prepared for MPI, but ProgressReport had to be changed (see line 44). We added a condition that only the master process (rank 0) will print to the screen. Without it, each process will write the same thing to the screen. The same goes for line 132. In line 128, each processes writes its data to a file. If the file name had been the same, all processes would try to write to the same file and the information would be corrupted. The way it's written, each process writes to a file ith a slightly different file name. Finally, MPI is terminated at line 136. 

In order to run this example, use
{{{
make MODE=parallel TARGET=...
}}}
and replace the ellipses with the proper path. By default, parallel runs are executed with just two processes. To change the number of processes (to, say, 18), use
{{{
make MODE=parallel NUM_PROCESSES=18 TARGET=...
}}}
Note that at the moment we only support an even number of processes. Trying to run with an odd number will result in an error.